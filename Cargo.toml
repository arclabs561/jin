[package]
name = "jin"
version = "0.1.0"
authors = ["Arc <attobop@gmail.com>"]
edition = "2021"
rust-version = "1.80"
description = "Approximate Nearest Neighbor Search: HNSW, DiskANN, IVF-PQ, ScaNN, quantization"
repository = "https://github.com/arclabs561/jin"
license = "MIT OR Apache-2.0"
keywords = ["ann", "hnsw", "vector-search", "similarity", "nearest-neighbor"]
categories = ["algorithms", "science"]

[lib]
# Keep `rlib` for normal Rust usage; add `cdylib` for optional PyO3 builds.
crate-type = ["rlib", "cdylib"]

[dependencies]
smallvec = { version = "1.11", features = ["serde"] }
rand = "0.9"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
bitflags = "2.4"
ordered-float = "4.2"
parking_lot = "0.12"
rayon = "1.10"
thiserror = "2.0"
log = "0.4"

# Python bindings (feature-gated; used for ann-benchmarks integration)
# Note: do NOT enable `pyo3/extension-module` here. It breaks `cargo test --all-features`
# by disabling libpython linking for test binaries on macOS.
# Maturin sets `PYO3_BUILD_EXTENSION_MODULE=1` when building wheels.
pyo3 = { version = "0.27.2", optional = true }
numpy = { version = "0.27.0", optional = true }

# SIMD primitives (ecosystem crate)
innr = { version = "0.1.0", optional = true }

# High-performance SIMD (ashvardanian/SimSIMD bindings)
# Provides up to 200x speedups for vector distance functions
simsimd = { version = "6.5.12", optional = true }

# ID compression primitives (ecosystem crate)
cnk = { version = "0.1.0", optional = true }

# Succinct data structures (ecosystem crate)
sbits = { version = "0.1.0", optional = true }

# Spectral statistics (optional).
rmt = { version = "0.1.0", path = "../rmt", optional = true }

# Stochastic sampling (ecosystem crate)
kuji = "0.1.0"

# Vector quantization primitives (extracted from `jin`)
qntz = { package = "qntz", version = "0.1.0", path = "../qntz", optional = true }

# Distributed Coordination
hiqlite = { version = "0.12", features = ["full"] }

# Persistence & IO
byteorder = "1.5"
crc32fast = "1.4"
libc = "0.2"
hex = "0.4"
fst = "0.4"
memmap2 = { version = "0.9", optional = true }
postcard = { version = "1.0", optional = true, features = ["use-crc", "alloc", "use-std"] }
bytemuck = { version = "1.14", optional = true, features = ["derive"] }
durability = { path = "../durability" }

# Legacy serialization (kept for backward compatibility)
bincode = { version = "1.3", optional = true }

[features]
default = ["hnsw", "innr"]
persistence = ["dep:postcard", "dep:bytemuck", "dep:memmap2"]
hnsw = []
ivf_pq = []
diskann = []
scann = []
sng = []
vamana = ["hnsw"]
quantization = ["qntz"]
nightly = []
innr = ["dep:innr"]
simsimd = ["dep:simsimd"]
python = ["dep:pyo3", "dep:numpy", "hnsw"]

# Feature names referenced by cfgs in the extracted code.
# These are currently mostly organizational toggles.
dense = []
nsw = []
kdtree = []
balltree = []
kmeans_tree = []
rptree = []
rmt-spectral = ["dep:rmt"]
evoc = []

id-compression = ["dep:cnk", "dep:sbits"]
succinct-filters = ["dep:sbits"]
persistence-bincode = ["dep:bincode", "persistence"]
memmap = ["persistence"]  # Alias for persistence with mmap focus

# Quantization sub-features (kept separate so callers can be explicit)
rabitq = ["qntz", "qntz/rabitq"]
saq = ["qntz", "qntz/ternary"]
turboquant = []

# Re-exported quantizers (from `qntz`)
qntz = ["dep:qntz"]

# Back-compat alias (older name used inside `jin` historically)
vquant = ["qntz"]

[dev-dependencies]
criterion = { version = "0.5", features = ["html_reports"] }
proptest = "1.5"
tempfile = "3"
memmap2 = "0.9"
tokio = { version = "1.40", features = ["macros", "rt-multi-thread"] }
anyhow = "1.0"

[[example]]
name = "ivf_pq_demo"
path = "examples/ivf_pq_demo.rs"
required-features = ["ivf_pq"]

[[example]]
name = "rabitq_demo"
path = "examples/rabitq_demo.rs"
required-features = ["rabitq"]

[[bench]]
name = "hnsw"
harness = false

[[bench]]
name = "distance"
harness = false

[[bench]]
name = "recall"
harness = false

[[bench]]
name = "memory"
harness = false

[[bench]]
name = "scaling"
harness = false

# [[bench]]
# name = "hnsw_adaptive"
# harness = false

[lints.rust]
rust_2018_idioms = { level = "warn", priority = -1 }
rust_2021_compatibility = { level = "warn", priority = -1 }
future_incompatible = { level = "warn", priority = -1 }
nonstandard_style = { level = "warn", priority = -1 }
# Allow cfg checks for internal feature toggles (classic ANN algorithms and optional data formats)
unexpected_cfgs = { level = "warn", check-cfg = [
    "cfg(feature, values(\"nsw\", \"kdtree\", \"balltree\", \"kmeans_tree\", \"rptree\", \"simd\", \"rand\", \"hdf5\", \"id-compression\", \"python\", \"succinct-filters\"))"
] }
# Documentation lints: temporarily relaxed, enable incrementally
# missing_docs = "warn"
# missing_doc_code_examples = "warn"
# unsafe_code = "warn"  # SIMD and low-level ops require unsafe
unstable_features = "deny"
unused_import_braces = "warn"
# unused_qualifications = "warn"  # Relaxed: explicit paths often improve clarity
# unused_results = "warn"  # Relaxed: HashSet/HashMap inserts often ignore return value
# trivial_numeric_casts = "warn"  # Relaxed: explicit casts help with type clarity
variant_size_differences = "warn"
unused_extern_crates = "warn"
unused_lifetimes = "warn"
semicolon_in_expressions_from_macros = "warn"
unsafe_op_in_unsafe_fn = "warn"
unused_macro_rules = "warn"

[lints.clippy]
correctness = { level = "deny", priority = -1 }
perf = { level = "warn", priority = -1 }
cargo = { level = "warn", priority = -1 }
complexity = { level = "warn", priority = -1 }
style = { level = "warn", priority = -1 }
suspicious = { level = "warn", priority = -1 }
restriction = { level = "allow", priority = -1 }
unwrap_in_result = "warn"
unwrap_used = "warn"
expect_used = "warn"
mutex_atomic = "warn"
large_enum_variant = "warn"
empty_loop = "deny"
never_loop = "warn"
doc_markdown = "allow"
too_many_arguments = "allow"
type_complexity = "allow"
multiple_crate_versions = "allow"
wrong_self_convention = "allow"
module_name_repetitions = "allow"
